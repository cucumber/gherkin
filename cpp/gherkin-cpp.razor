@using Berp;
@helper CallProduction(ProductionRule production)
{
  switch(production.Type)
  {
    case ProductionRuleType.Start:
      @:  start_rule(context, Rule_@production.RuleName);
      break;
    case ProductionRuleType.End:
      @:  end_rule(context, Rule_@production.RuleName);
      break;
    case ProductionRuleType.Process:
      @:  build(context, token);
      break;
  }
}
@helper HandleParserError(IEnumerable<string> expectedTokens, State state)
{<text>
    /* "State: @state.Id - @Raw(state.Comment)" */
    std::string expected_tokens = L"@Raw(string.Join(", ", expectedTokens))";

    auto error =
        token.is_eof()
        ? error_type::unexpected_eof
        : error_type::unexpected_token
        ;

    if (stop_at_first_error()) {
        throw_error(error, token, expected_tokens);
    }

    add_error(error, token, expected_tokens);

    return @state.Id;</text>}
@helper MatchToken(TokenType tokenType)
{<text>match_@(tokenType)(context, token)</text>}
// This file is generated. Do not edit! Edit gherkin-cpp-parser.razor instead.
#include <gherkin/parser.hpp>
#include <gherkin/token_scanner.hpp>
//#include <gherkin/error_list.hpp>

namespace gherkin {

enum class rule_type {
    None = 0,
    @foreach(var rule in Model.RuleSet.Where(r => !r.TempRule))
    {<text>    @rule.Name.Replace("#", ""),
</text>}
    Count
};

parser::parser(const parser_info& pi)
: pi_{pi}
{}

int
parser::parse(const file& file)
{
    ts_.reset(file);

    return 0;
}
