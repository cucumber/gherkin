@using Berp;
@helper CallProduction(ProductionRule production)
{
    switch(production.Type) {
        case ProductionRuleType.Start:
                @:startRule(context, RuleType.@production.RuleName);
            break;
        case ProductionRuleType.End:
                @:endRule(context, RuleType.@production.RuleName);
            break;
        case ProductionRuleType.Process:
                @:build(context, token);
            break;
    }
}
@helper HandleParserError(IEnumerable<string> expectedTokens, State state)
{<text>
        final String stateComment = "State: @state.Id - @Raw(state.Comment)";
        List<String> expectedTokens = asList("@Raw(string.Join("\", \"", expectedTokens))");
        ParserException error = token.isEOF()
                ? new ParserException.UnexpectedEOFException(token, expectedTokens, stateComment)
                : new ParserException.UnexpectedTokenException(token, expectedTokens, stateComment);

        addError(context, error);
        return @state.Id;
</text>}
@helper matchToken(TokenType tokenType)
{<text>match_@(tokenType)(context, token)</text>}
package io.cucumber.gherkin;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Queue;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;

import static java.util.Arrays.asList;

/**
 * This class was generated by <a href=http://https://github.com/gasparnagy/berp>Berp</a>.
 * <p>
 * Changes to this class will be lost if the code is regenerated.
 */
final class @Model.ParserClassName<T> {
    enum TokenType {
        None(RuleType.None),
        @foreach(var rule in Model.RuleSet.TokenRules)
        {<text>        @(rule.Name.Replace("#", ""))(RuleType.@(rule.Name.Replace("#", "_"))),
</text>}        ;

        final RuleType ruleType;

        TokenType(RuleType ruleType) {
            this.ruleType = ruleType;
        }
    }

    enum RuleType {
        None,
        @foreach(var rule in Model.RuleSet.Where(r => !r.TempRule))
        {<text>        @rule.Name.Replace("#", "_"), // @rule.ToString(true)
</text>}        ;

    }

    private final Builder<T> builder;

    static final class ParserContext {
        final TokenScanner tokenScanner;
        final TokenMatcher tokenMatcher;
        final Queue<Token> tokenQueue;
        final List<ParserException> errors;

        ParserContext(TokenScanner tokenScanner, TokenMatcher tokenMatcher, Queue<Token> tokenQueue, List<ParserException> errors) {
            this.tokenScanner = tokenScanner;
            this.tokenMatcher = tokenMatcher;
            this.tokenQueue = tokenQueue;
            this.errors = errors;
        }
    }

    Parser(Builder<T> builder) {
        this.builder = builder;
    }

    T parse(String source, String uri) {
        return parse(new TokenScanner(source), uri);
    }

    T parse(TokenScanner tokenScanner, String uri) {
        return parse(tokenScanner, new GherkinTokenMatcher(), uri);
    }

    T parse(String source, TokenMatcher tokenMatcher, String uri) {
        return parse(new TokenScanner(source), tokenMatcher, uri);
    }

    T parse(TokenScanner tokenScanner, TokenMatcher tokenMatcher, String uri) {
        builder.reset(uri);
        tokenMatcher.reset();

        ParserContext context = new ParserContext(
                tokenScanner,
                tokenMatcher,
                new ArrayDeque<>(),
                new ArrayList<>()
        );

        startRule(context, RuleType.@Model.RuleSet.StartRule.Name);
        int state = 0;
        Token token;
        do {
            token = readToken(context);
            state = matchToken(state, token, context);
        } while (!token.isEOF());

        endRule(context, RuleType.@Model.RuleSet.StartRule.Name);

        if (!context.errors.isEmpty()) {
            throw new ParserException.CompositeParserException(context.errors);
        }

        return builder.getResult();
    }

    private void addError(ParserContext context, ParserException error) {
        String newErrorMessage = error.getMessage();
        for (ParserException e : context.errors) {
            if (Objects.equals(e.getMessage(), newErrorMessage)) {
                return;
            }
        }
        context.errors.add(error);
        if (context.errors.size() > 10)
            throw new ParserException.CompositeParserException(context.errors);
    }

    private <V> void handleAstError(ParserContext context, V value, Builder<T> b, final BiConsumer<Builder<T>, V> action) {
        try {
            action.accept(b, value);
        } catch (ParserException.CompositeParserException compositeParserException) {
            for (ParserException error : compositeParserException.errors) {
                addError(context, error);
            }
        } catch (ParserException error) {
            addError(context, error);
        }
    }

    private boolean handleExternalError(ParserContext context, Token token,
                                        BiPredicate<TokenMatcher, Token> action) {
        try {
            return action.test(context.tokenMatcher, token);
        } catch (ParserException.CompositeParserException compositeParserException) {
            for (ParserException error : compositeParserException.errors) {
                addError(context, error);
            }
        } catch (ParserException error) {
            addError(context, error);
        }
        return false;
    }

    private void build(final ParserContext context, final Token token) {
        handleAstError(context, token, builder, Builder::build);
    }

    private void startRule(final ParserContext context, final RuleType ruleType) {
        handleAstError(context, ruleType, builder, Builder::startRule);
    }

    private void endRule(final ParserContext context, final RuleType ruleType) {
        handleAstError(context, ruleType, builder, Builder::endRule);
    }

    private Token readToken(ParserContext context) {
        return context.tokenQueue.isEmpty() ? context.tokenScanner.read() : context.tokenQueue.remove();
    }
@foreach(var rule in Model.RuleSet.TokenRules)
{<text>
    private boolean match_@(rule.Name.Replace("#", ""))(final ParserContext context, final Token token) {
        @if (rule.Name != "#EOF")
        {
        @:if (token.isEOF()) return false;
        }
        return handleExternalError(context, token, TokenMatcher::match_@(rule.Name.Replace("#", "")));
    }
</text>
}

    private int matchToken(int state, Token token, ParserContext context) {
        int newState = switch (state) {
        @foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
        {
            @:case @state.Id -> matchTokenAt_@(state.Id)(token, context);
        }
            default -> {
                throw new IllegalStateException("Unknown state: " + state);
            }
        };
        return newState;
    }
@foreach(var state in Model.States.Values.Where(s => !s.IsEndState))
{
<text>
    // @Raw(state.Comment)
    private int matchTokenAt_@(state.Id)(Token token, ParserContext context) {
        @foreach(var transition in state.Transitions)
        {
        @:if (@matchToken(transition.TokenType))
        @:{
            if (transition.LookAheadHint != null)
            {
            @:if (lookahead_@(transition.LookAheadHint.Id)(context))
            @:{
            }
            foreach(var production in transition.Productions)
            {
                @CallProduction(production)
            }
            @:return @transition.TargetState;
            if (transition.LookAheadHint != null)
            {
            @:}
            }
        @:}
        }
        @HandleParserError(state.Transitions.Select(t => "#" + t.TokenType.ToString()).Distinct(), state)
    }
</text>
}

@foreach(var lookAheadHint in Model.RuleSet.LookAheadHints)
{
<text>
    private boolean lookahead_@(lookAheadHint.Id)(ParserContext context) {
        Token token;
        Queue<Token> queue = new ArrayDeque<Token>();
        boolean match = false;
        do
        {
            token = readToken(context);
            queue.add(token);

            if (false
            @foreach(var tokenType in lookAheadHint.ExpectedTokens)
            {
                @:|| @matchToken(tokenType)
            }
            )
            {
                match = true;
                break;
            }
        } while (false
        @foreach(var tokenType in lookAheadHint.Skip)
        {
            @:|| @matchToken(tokenType)
        }
        );

        context.tokenQueue.addAll(queue);

        return match;
    }
</text>
}

    interface Builder<T> {
        void build(Token token);
        void startRule(RuleType ruleType);
        void endRule(RuleType ruleType);
        T getResult();
        void reset(String uri);
    }

    interface TokenMatcher {
        @foreach(var rule in Model.RuleSet.TokenRules)
        {
        @:boolean match_@(rule.Name.Replace("#", ""))(Token token);
        }
        void reset();
    }
}
